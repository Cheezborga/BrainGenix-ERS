#version 330 core

// Set Outputs
out vec4 FragColor;

// Set Inputs
in vec2 TexCoords;
in vec3 FragPos;
in vec3 Normal;





// Define Structs
struct STRUCT_DirectionalLight {

    vec3 Position;

    // Light Color Parameters
    vec3 AmbientColor;
    vec3 DiffuseColor;
    vec3 SpecularColor;

};

struct STRUCT_PointLight {

    // Physical Parameters
    vec3 Position;

    // Light Color Parameters
    vec3 AmbientColor;
    vec3 DiffuseColor;
    vec3 SpecularColor;

    // Light Rolloff Parameters
    float ConstantRolloff;
    float LinearRolloff;
    float QuadraticRolloff;

};

struct STRUCT_SpotLight {

    // Physical Parameters
    vec3 Position;
    vec3 Direction;

    // Light Color Parameters
    vec3 AmbientColor;
    vec3 DiffuseColor;
    vec3 SpecularColor;

    // Light Rolloff Parameters
    float ConstantRolloff;
    float LinearRolloff;
    float QuadraticRolloff;

    // Spotlight Parameters
    float CutOff;
    float OuterCutOff;

};

struct STRUCT_Material {

    sampler2D Diffuse;
    sampler2D Specular;
    sampler2D Normal;
    sampler2D Height;

    float Shinyness;

};

struct STRUCT_SampledData {

    vec4 DiffuseTextureColor;
    vec4 SpecularTextureColor;
    vec4 NormalTextureColor;
    vec4 HeightTextureColor;

};





// Get Metadata Params
uniform int FrameNumber; // Number of the frame, counts up from zero

uniform float Time; // Time since program started in seconds
uniform float FrameTime; // Render Time Of The Frame

uniform vec2 ViewportRes; // XY Resolution of the viewport
uniform vec3 CameraPosition; // Get Camera XYZ Position



// Get Texture Info
uniform STRUCT_Material Material;

// Get Lighting Info
#define MAXIMUM_DIRECTIONAL_LIGHTS 4;
#define MAXIMUM_POINT_LIGHTS 256;
#define MAXIMUM_SPOT_LIGHTS 128;

uniform int NumberDirectionalLights;
uniform STRUCT_DirectionalLight DirectionalLights[MAXIMUM_DIRECTIONAL_LIGHTS];
uniform int NumberPointLights;
uniform STRUCT_PointLight PointLights[MAXIMUM_POINT_LIGHTS];
uniform int NumberSpotLights;
uniform STRUCT_SpotLight SpotLights[MAXIMUM_SPOT_LIGHTS];




// Declare Light Calculation Functions
CalculateDirectionalLight(STRUCT_DirectionalLight Light, STRUCT_SampledData SampledData, vec3 Normal, vec3 ViewDirection);
CalculatePointLight(STRUCT_PointLight Light, STRUCT_SampledData SampledData, vec3 Normal, vec3 FragPos, vec3 ViewDirection);
CalculateSpotLight(STRUCT_SpotLight Light, STRUCT_SampledData SampledData, vec3 Normal, vec3 FragPos, vec3 ViewDirection);



void main()
{    


    // ---- Extract Texture Vectors, Create SampledData Struct ---- //
    STRUCT_SampledData SampledData;

    SampledData.DiffuseTextureColor = texture(Material.Diffuse, TexCoords);
    SampledData.SpecularTextureColor = texture(Material.Specular, TexCoords);
    SampledData.NormalTextureColor = texture(Material.Normal, TexCoords);
    SampledData.HeightTextureColor = texture(Material.Height, TexCoords);
    

    // ---- Calculate Lighting Contributions ---- //
    vec4 Result = vec4(0.0f);

    // Calculate Directional Lights
    for (int i = 0; i < NumberDirectionalLights; i++) {
        Result += CalculateDirectionalLight(DirectionalLights[i], SampledData, Normal, ViewDirection);
    }

    // Calculate Point Lights
    for (int i = 0; i < NumberPointLights; i++) {
        Result += CalculatePointLight(PointLights[i], SampledData, Normal, FragPos, ViewDirection);
    }

    // Calculate Spot Lights
    for (int i = 0; i < NumberSpotLights; i++) {
        Result += CalculateSpotLight(SpotLights[i], SampledData, Normal, FragPos, ViewDirection);
    }
    
    FragColor = Result;
    
}


vec4 CalculateDirectionalLight(STRUCT_DirectionalLight Light, STRUCT_SampledData SampledData, vec3 Normal, vec3 ViewDirection) {
    
    vec3 LightDirectionVector = normalize(-Light.Direction);
    vec3 ReflectionDirectionVector = normalize(-LightDirectionVector, Normal);

    // Diffuse/Specular Components
    float Diffuse = max(dot(Normal, LightDirectionVector), 0.0f);
    float Specular = pow(max(dot(ViewDirection, ReflectionDirectionVector), 0.0f), Material.Shinyness);

    // Calculate Total Contribution From Components
    vec4 AmbientComponent = vec4(Light.Ambient, 1.0f) * SampledData.DiffuseTextureColor;
    vec4 DiffuseComponent = vec4(Light.Diffuse, 1.0f) * Diffuse * SampledData.DiffuseTextureColor;
    vec4 SpecularComponent = vec4(Light.Specular, 1.0f) * Specular * SampledData.SpecularTextureColor;

    return (AmbientComponent + DiffuseComponent + SpecularComponent);

}

vec4 CalculatePointLight(STRUCT_PointLight Light, STRUCT_SampledData SampledData, vec3 Normal, vec3 FragPos, vec3 ViewDirection) {

    vec3 LightDirectionVector = normalize(Light.Direction - FragPos);
    vec3 ReflectionDirectionVector = normalize(-LightDirectionVector, Normal);

    // Diffuse/Specular Components
    float Diffuse = max(dot(Normal, LightDirectionVector), 0.0f);
    float Specular = pow(max(dot(ViewDirection, ReflectionDirectionVector), 0.0f), Material.Shinyness);

    // Attenuate 
    float Distance = length(Light.Position - FragPos);
    float Attenuation = 1.0f / (Light.ConstantRolloff + Light.LinearRolloff * Distance + Light.QuadraticRolloff * (Distance * Diffuse));

    // Calculate Total Contribution From Components
    vec4 AmbientComponent = vec4(Light.Ambient * Attenuation, 1.0f) * SampledData.DiffuseTextureColor;
    vec4 DiffuseComponent = vec4(Light.Diffuse * Attenuation, 1.0f) * Diffuse * SampledData.DiffuseTextureColor;
    vec4 SpecularComponent = vec4(Light.Specular * Attenuation, 1.0f) * Specular * SampledData.SpecularTextureColor;

    return (AmbientComponent + DiffuseComponent + SpecularComponent);

}

vec4 CalculateSpotLight(STRUCT_SpotLight Light, STRUCT_SampledData SampledData, vec3 Normal, vec3 FragPos, vec3 ViewDirection) {

    vec3 LightDirectionVector = normalize(Light.Direction - FragPos);
    vec3 ReflectionDirectionVector = normalize(-LightDirectionVector, Normal);

    // Diffuse/Specular Components
    float Diffuse = max(dot(Normal, LightDirectionVector), 0.0f);
    float Specular = pow(max(dot(ViewDirection, ReflectionDirectionVector), 0.0f), Material.Shinyness);

    // Calculate Attenuation
    float Distance = length(Light.Position - FragPos);
    float Attenuation = 1.0f / (Light.ConstantRolloff + Light.LinearRolloff * Distance + Light.QuadraticRolloff * (Distance * Diffuse));

    // Calculate Spot Intensity
    float Theta = dot(LightDirectionVector, normalize(-Light.Direction));
    float Epsilon = Light.CutOff - Light.OuterCutOff;
    float Intensity = clamp((Theta - Light.OuterCutOff) / Epsilon, 0.0f, 1.0f);

    // Calculate Total Contribution From Components
    vec4 AmbientComponent = vec4(Light.Ambient * Attenuation * Intensity, 1.0f) * SampledData.DiffuseTextureColor;
    vec4 DiffuseComponent = vec4(Light.Diffuse * Attenuation * Intensity, 1.0f) * Diffuse * SampledData.DiffuseTextureColor;
    vec4 SpecularComponent = vec4(Light.Specular * Attenuation * Intensity, 1.0f) * Specular * SampledData.SpecularTextureColor;

    return (AmbientComponent + DiffuseComponent + SpecularComponent);

}
